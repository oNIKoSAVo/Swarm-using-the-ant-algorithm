# Применение роевого интеллекта с использованием муравьиного алгоритма и модели доверия в задаче оптимизации маршрутов подключения в сети

**Структура проекта**: 
- /main.py - основной файл запуска. 
- /ant_colony.py - реализация муравьиного алгоритма.
- /graph_helpers.py - файл реализующий отрисовки.
- /util.py - вспомогательные функции.
- /computer_end.png и  computer_start.png - картинки для начального и конечного узла.

**Как запускать**: 
1. Открываем окно консоли
2. Вводим `python main.py runserver`
<br/>


**Описание алгоритма**:

1. Инициализация переменных и структур данных:
Данные для алгоритма представлены следующим образом:

G: Граф, представляющий пространство решений, где узлы - точки, а ребра - пути между этими точками со связанной стоимостью (или весом)
ants_count: Количество муравьев, которые перемещаются по графу в каждой итерации
alpha и beta: Параметры, определяющие степень влияния количества феромона (alpha) и обратной стоимости ребра (beta) на вероятность выбора этого ребра муравьем
evaporation_rate: Фактор, определяющий, как быстро феромон испаряется с ребра
edge_pheromone: Словарь, где ключами являются кортежи (u, v), соответствующие ребрам графа G, а значениями - текущее количество феромона на ребре
start_node, end_node: Задача состоит в том, чтобы переместить муравьев из начальной позиции (узла) start_node до конечной позиции (узла) end_node
iterations: Количество итераций, за которое алгоритм должен научиться находить оптимальный путь между заданными узлами
trust_scores: Оценка доверия узлов, где ключами будут индексы узлов графа G, а значениями - их соответствующие оценки доверия
2. Основной цикл алгоритма:
Каждая итерация проходит по следующим шагам:

Инициализируются структуры данных для текущего муравья: пустой список visited_edges и probabilities_all.

Муравей перемещается по графу, начиная с start_node и пытается достичь end_node:

Ищутся все ребра, исходящие из текущего узла, и для каждого ребра (current_node, v) вычисляются вероятности перехода, основанные на количестве феромона на ребре (tau) и обратной стоимости ребра (eta). Также получаются оценки доверия узлов (trust).
Если сумма вероятностей равна нулю, учитывается случайный выбор ребра.
Если сумма вероятностей больше нуля, производится нормализация вероятностей и корректируются оценками доверия. Затем на основе полученных вероятностей следующее ребро выбирается муравьем.
На каждом шаге вероятности перехода между узлами сохраняются в probabilities_all.

После того как муравей достигает конечного узла, вычисляется увеличение феромона (delta_pheromone) на основе общего веса всех посещенных ребер. Затем инкрементируется феромон на каждом посещенном ребре.

3. Обновление феромона на ребрах (испарение и регулировка нагрузки):

Количество феромона на всех ребрах уменьшается посредством умножения их текущего значения на (1 - evaporation_rate).
Если количество феромона на ребре превышает заданный порог (5 в данном случае), его значение устанавливается равным максимально допустимому порогу.
Алгоритм возвращает список вероятностей probabilities_all, соответствующих путям между узлами графа, обновленный после одной итерации поиска пути для каждого муравья. Выполнив несколько итераций алгоритма, можно получить самый вероятный путь между начальным и конечным узлами на основе распределения феромонов.



Расширенная формула для учета оценок доверия и муравьиного алгоритма
Расширенная формула для учета оценок доверия и муравьиного алгоритма выглядит следующим образом:

P_ijk(t) = (τ_ij(t)^α × η_ij^β × T_j) / Σ(τ_il(t)^α × η_il^β × T_l)

где:

P_ijk(t) - вероятность выбора ребра (i, j) муравьем k на итерации t;
τ_ij(t) - количество феромонов на ребре (i, j) на итерации t;
η_ij - обратная стоимость ребра (характеристика привлекательности ребра);
α - параметр, контролирующий влияние феромонов;
β - параметр, контролирующий влияние привлекательности ребра;
T_j - оценка доверия узла j;
Σ(τ_il(t)^α × η_il^β × T_l) - сумма произведений (феромоны × привлекательность ребра × оценка доверия дочернего узла) для всех смежных ребер вершины i.
Эта формула представляет вероятность выбора ребра (i, j) муравьем k на итерации t с учетом количества феромона, стоимости ребра и оценки доверия узла j. Реализация этой формулы в коде была представлена в строках:

probabilities_temp = [(probability / sum(probability for probability in probabilities))  for probability in probabilities]
                probabilities_temp2 = [(p*t)  for p, t in zip(probabilities_temp, trusts)]



4. Обновления феромонов
Стандартная формула для обновления феромонов на ребрах графа в муравьином оптимизационном алгоритме (ACO) выглядит так:

Δτ_ij(t) = Q / L_k(t)

где:

Δτ_ij(t) - количество феромона, которое муравей k оставляет на ребре (i, j) на итерации t.
Q - константа, контролирующая количество феромона, которое муравей оставляет за одно перемещение.
L_k(t) - длина маршрута муравья k на итерации t.
В коде, который Вы указали выше, эта формула применяется следующим образом:

 delta_pheromone = 1 / sum(G[u][v]['weight'] for u, v in visited_edges)

Здесь мы считаем δ_pheromone, что в данном случае аналогично Δτ_ij(t), равным 1 / L_k(t) , где L_k(t) — сумма весов всех посещенных ребер на текущей итерации.

В данной реализации константа Q равна 1, однако в других реализациях муравьиного оптимизационного алгоритма её можно регулировать для контроля количества откладываемого феромона.









Испарение
Эта строка кода отвечает за процесс испарения (уменьшения) феромонов на ребрах графа.

evaporation_rate - это коэффициент испарения феромона, который контролирует скорость, с которой феромоны уменьшаются на ребрах после каждой итерации алгоритма. Значение evaporation_rate находится в интервале от 0 до 1. Значение, близкое к 0, означает медленное испарение феромонов, а значение, близкое к 1, означает быстрое испарение.

edge_pheromone[edge] - текущее значение феромона на данном ребре (edge).

edge_pheromone[edge] *= (1 - evaporation_rate) - уменьшает текущее количество феромона на ребре, умножая его на (1 - evaporation_rate). Это обеспечивает, что феромоны на ребрах постепенно уменьшаются и влияние маршрутов, найденных в предыдущих итерациях, со временем угасает. Это позволяет алгоритму муравьиной колонии адаптироваться к изменениям графа и решать динамические оптимизационные задачи.